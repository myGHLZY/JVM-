# JVM(Java virtual Machine)

笔记主要参考黑马2023年的JVM讲解和周志明的深入理解JVM
---
## 1. jvm的组成  
![无法加载](img/截屏2024-03-02%2019.19.05.png)


主要包括四部分 类加载器(ClassLoader) JVM内存结构 执行引擎 本地方法接口

- JVM主要完成三项功能
    - 解释和运行  对字节码文件中的指令，实时的解释成机器码，让计算机执行
    - 内存管理 为对象分配空间，对不用的对象自动进行垃圾回收
    - 即时编译 对代码进行优化，提升性能
#### 我们来对Java语言做一个简单介绍
- 这里需要说明Java是一种***解释型***的语言，虽然我们要先将Java源代码编译成字节码文件，但是依然要借助于JVM将字节码一行一行的翻译。（也有人称为混合模式）而JVM主要是为了实现***跨平台***特性。
![](img/截屏2024-03-19%2011.36.34.png)

![](img/截屏2024-03-19%2011.36.48.png)

- Java还是一种***静态类型***的语言
  静态类型语言中，变量的类型必须先声明，即在创建的那一刻就已经确定好变量的类型，而后的使用中，你只能将这一指定类型的数据赋值给变量。而动态的编程语言则没这个问题，变量的类型不是固定的，可以自由转变。  
    常见的动态类型的语言有：PHP、Ruby、Python
    静态类型的语言：C、C++、JAVA、C#
- Java还是一种***运行时语言***
  简单来说，JRE（Java Runtime Environment）就是Java的运行时，JRE中包含了虚拟机和相关的库等资源。可以说运行时提供了程序运行的基本环境，JVM在启动时需要加载所有运行时的核心库等资源，然后再加载我们的应用程序字节码，才能让应用程序字节码运行在JVM这个容器里。
![](img/截屏2024-03-19%2011.46.49.png)
- Java还是面向对象的语言，这点不再赘述



## 2. java字节码文件
![](img/截屏2024-03-02%2022.55.47.png)
- 基础信息
- 常量池
- 字段
- 方法
- 属性   
 
使用jclasslib
  ![](img/截屏2024-03-02%2023.01.03.png)

### 2.1 基本信息
  #### 2.1.1魔数
    Java字节码文件用与确定文件类型的文件头(cafe babe)
  #### 2.1.2 主副版本号
    主副版本号指的是编译字节码文件的JDK版本号，主版本号用来标识大版本号,JDK1.0-1.1使用了45.0-45.3，JDK1.2是46之后每升级一个大版本就加1；副版本号是当主版本号相同时作为区分不同版本的标识，一般只需要关心主版本号。(jdk8的主版本号为52)
  #### 2.1.3 访问标识
  #### 2.1.4 类，父类，接口索引

### 2.2 Class文件常量池
 参考(https://zhuanlan.zhihu.com/p/431237260#:~:text=%E8%BF%99%E4%BA%9B%E5%9C%A8JVM%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%97%B6%E5%80%99%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81%EF%BC%8C%E6%89%80%E4%BB%A5%E7%BC%96%E8%AF%91%E5%99%A8%E5%B0%86%E6%BA%90%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91%E6%88%90,class%20%E6%96%87%E4%BB%B6%E4%B9%8B%E5%90%8E%EF%BC%8C%E4%BC%9A%E7%94%A8%E4%B8%80%E9%83%A8%E5%88%86%E5%AD%97%E8%8A%82%E5%88%86%E7%B1%BB%E5%AD%98%E5%82%A8%E8%BF%99%E4%BA%9B%E4%B8%8D%E5%8F%98%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%8C%E8%80%8C%E8%BF%99%E4%BA%9B%E5%AD%97%E8%8A%82%E6%88%91%E4%BB%AC%E5%B0%B1%E7%A7%B0%E4%B8%BA%E5%B8%B8%E9%87%8F%E6%B1%A0%E3%80%82)  

这篇文章关于谁进常量池的说法有问题，在一些配图上，也有问题。

1. 原因：避免相同的内容重复定义，节省空间。里面主要存放编译器生成的各种字面量和符号引用。字节码指令中通过编号引用到常量池的过程称之为符号引用。
2. 对于String类型的变量，需要注意,在字节码常量池中，会先符号引用到String_info,再通过String_info引用对应的常量。原因有二，其一：表示这是一个字符串，假如有同名的方法名或者其他相区分；其二，在JVM中，会存在串池，我们会将这些字符串常量放入串池。
3. 关于到底哪些东西进文件常量池  
    1. float 、double 、 long 以及普通的String赋值进常量池
    2. 被final修饰的进常量池 (因为类加载时机的问题)
    3. 特殊的关于String
    ```
    final String a="ab";
    final String b="a"+"b";
    String c=a+b;
    上述在编译期间就可确定，c的 "abab"进常量池
    ```
    4. 关于int，在指令集中，有一系列将特定int类型推入栈中的指令，因此，这些特定的数，不进常量池(参考:https://blog.csdn.net/Viscu/article/details/87539838)
   ![](img/截屏2024-03-19%2014.37.09.png)
4. 关于常量池到底如何存放数据
   - 不做赘述 参考：https://blog.csdn.net/fengyuyeguirenenen/article/details/123400205
   - 上下两篇，非常详细
   



### 2.3 方法
1. 方法的Code会存放***字节码指令***
   #### 2.3.1 字节码指令
    - 存在一个操作数栈暂时存放数据
    - 存在一个局部变量表按顺序存放局部变量(第0个是args)  
  
  几个常见的指令  

  - iconst_n 将常量 n 放入操作数栈
  - istore_n pop操作数栈，将数放入局部变量表的n号位置
  - iload_n  将局部变量表n号位置的数push到操作数栈中
  - iadd     将操作数栈上的两个数相加，再push进栈
  - iinc loc by n 在局部变量表的loc位置增加n(不涉及操作数栈)
  
  关于 i++ 和 ++i
  ![](img/截屏2024-03-03%2000.30.18.png)
  ![](img/截屏2024-03-03%2000.30.35.png)

- 我们需要说明.class文件和字节码指令bytecode的区别
  - .class: 是指文件扩展名称为.class的文件,表示由java源程序经过java编译器编译而成且由JVM执行的二进制文件,因此可以通过拥有一份.class文件在不同的操作系统平台上的JVM执行,实现跨平台运行的特性
  - 字节码bytecode: 简单说不是文件,而是JVM操作的指令格式,通常我们通过javap -c -v xx.class生成的文件称为字节码文件,是属于可阅读的字节码指令文件,能够让我们清楚地知道java文件编译成.class文件之后显示的执行指令,便于程序员理解jvm的相关的知识
- 关于字节码文件的整体样貌，参考 https://zhuanlan.zhihu.com/p/99899962   另外也有很多这方面的资料，不再赘述


## 3. 类的生命周期  
- 类的生命周期分为5个阶段分别是 加载 -> 链接 -> 初始化 -> 使用 -> 卸载
- 其中 链接可细分为 验证 -> 准备 -> 解析
![](img/截屏2024-03-19%2014.58.48.png)
### 3.1 类的加载
 1. 加载(Loading)阶段第一步是类加载器根据类的全限定名通过不同的渠道以二进制流的方式获取字节码信息。
 2. 类加载器在加载完类之后，Java虚拟机会将字节码中的信息保存到方法区中。
 3. 类加载器在加载完类之后，Java虚拟机会将字节码中的信息保存到内存的方法区中。生成一个InstanceKlass对象，保存类的所有信息，里边还包含实现特定功能比如多态的信息。
 4. 同时，Java虚拟机还会在堆中生成一份与方法区中数据类似的java.lang.Class对象。作用是在Java代码中去获取类的信息以及存储静态字段的数据（JDK8及之后）。
![](img/截屏2024-03-19%2015.02.52.png)
   
### 3.2 类的链接
1. 链接的第一个阶段是验证，检测字节码文件是否遵循《Java虚拟机规范》  
    - 文件格式验证，比如文件是否以0xCAFEBABE开头，主次版本号是否满足当前Java虚拟机版本要求。
    - 元信息验证，例如类必须有父类（super不能为空）。
    - 验证程序执行指令的语义，比如方法内的指令执行中跳转到不正确的位置。
    - 符号引用验证，例如是否访问了其他类中private的方法等。
2. 链接的第二个阶段是准备阶段(JDK8后)  
   
   - 准备阶段为静态变量（static）分配内存并设置初始值。
  ![](img/截屏2024-03-03%2010.59.23.png)
   - final修饰的基本数据类型的静态变量，准备阶段直接会将代码中的值进行赋值。

1. 链接的第三个阶段是解析
   - 解析阶段主要是将常量池中的符号引用替换为直接引用。直接引用不在使用编号，而是使用内存中地址进行访问具体的数据。
### 3.3类的初始化阶段

1. 初始化阶段会执行静态代码块中的代码(只会执行一次)，并为静态变量赋值。
2. 初始化阶段会执行字节码文件中clinit部分的字节码指令。(实际上clinit部分就是在执行静态变量赋值和静态代码块，他的字节码顺序和代码编写顺序一致)
3. 类初始化的诱因  
   
   - 调用Class.forName(String className)
   - new一个该类的对象时
   - 执行Main方法的当前类(当前类初始化)
   - 访问一个类的静态变量或者静态方法。注意变量是final修饰的并且等号右边是常量不会触发初始化
   - 当无静态代码块或是无静态变量/有静态变量的声明，但是没有赋值语句，这类变量会在准备阶段直接进行初始化 这些情况，不会触发clinit
   - 注意 类的其他代码块会在构造方法之前执行，并且在原本的构造方法之前
   - 注意 类的静态方法不会被主动调用
   - 需要注意的是 类的各种信息包括静态方法、静态代码块、静态变量等，在类的加载阶段就都已经加载进JVM中，而在类的初始化阶段，静态代码块会被主动执行一次
   - 直接访问父类的静态变量，不会触发子类的初始化。
   - 子类的初始化clinit调用之前，会先调用父类的clinit初始化方法
   - -xx:+TraceClassLoading
   - 创建对象数组只会在堆内存中为数组本身分配空间，不会引起数组元素的初始化,并为数组的每个元素设置默认的引用值

  
## 4. 类加载器
类加载器（ClassLoader）是Java虚拟机提供给应用程序去实现获取类和接口字节码数据的技术。类加载器只参与加载过程中的字节码获取并加载到内存这一部分。
### 4.1 类加载器的分类  
- 类加载器分为两类 一类是java虚拟机底层实现的 使用与虚拟机一致的语言Hotspot就使用的C++，这类加载器主要负责加载Java程序中的基础类，而且一般不能在Java代码中获得(null)
- 第二类是java的jdk实现的 所有的类加载器都要继承ClassLoader这个抽象类
- 在jdk8前，底层实现的类加载器有 BootstrapClassLoader(启动类加载器，一般加载Java中最核心的类) 而jdk自带的有 ExtClassLoader(拓展类加载器)和AppClassLoader(应用类加载器)

### 4.2 默认加载
- BootstrapClassLoader默认加载Java安装目录/jre/lib下的类文件，比如rt.jar，
tools.jar，resources.jar等(使用-Xbootclasspath/a:jar包目录/jar包名 进行扩
展)
- ExtClassLoader默认加载Java安装目录/jre/lib/ext下的类文件。(使用-Djava.ext.dirs=jar包目录 进行扩展,这种方式会覆盖掉原始目录，可以用;(windows):(macos/linux)追加上原始目录)
![](img/截屏2024-03-03%2022.26.56.png)
- 在arthas中通过 sc -d 权限类名 查看类的各种信息
![](img/截屏2024-03-03%2022.32.54.png)

- 在arthas中通过 classloader -l 查看类加载器的详情
- 在arthas中通过 classloader -c hash 查看类加载器加载的所有类

### 4.3 双亲委派机制
- 每个Java实现的类加载器中保存了一个成员变量叫“父”（Parent）类加载器，可以理解为它的上级，并不是继承关系。
  ![](img/截屏2024-03-03%2022.47.10.png)
- 在arthas中通过classloader -t 查看类的继承关系

1. 在类加载的过程中，每个类加载器都会先检查是否已经加载了该类，如果已经加载则直接返回，否则会将加载请求委派给父类加载器。(如果类加载的parent为null，则会提交给启动类加载器处理)
2. 如果所有的父类加载器都无法加载该类，则由当前类加载器自己尝试加载。所以看上去是自顶向下尝试加载。
3. 第二次再去加载相同的类，仍然会向上进行委派，如果某个类加载器加载过就会直接返回。
4. 双亲委派机制指的是：自底向上查找是否加载过，再由顶向下进行加载。
![](img/截屏2024-03-03%2022.52.26.png)
### 4.4 打破双亲委派机制
#### 4.4.1 自定义类加载器
![](img/截屏2024-03-03%2022.54.48.png)

- 注意 在loadClass方法中默认调用重载方法的另一个参数是false 表明不进入类的链接阶段 而通过Class.forName会默认初始化类
#### 4.4.2 线程上下文类加载器(JDBC)
- 在Java中 有java.sql.Driver 类，这个类位于核心rt.jar中，由启动类加载器加载。定义了数据库驱动的规范，而具体的实现由各个数据库公司提供。我们的Java通过DriverManager管理这些驱动。
- 而这些具体的驱动则要由AppClassLoader加载。
- 对于jdbc我们注意到，在之前的低版本中 需要手动的Class.forName("com.mysql.cj.jdbc.Driver") 这是手动加载Driver类，在Driver类的静态代码块中，完成了将Driver加载到DriverManager的工作。在mysql4.0以上，由于SPI技术的存在，已经不需要手动注册驱动类了。
    ![](img/截屏2024-03-03%2023.56.55.png)
    ![](img/截屏2024-03-03%2023.58.25.png)
- JDBC只是在DriverManager加载完之后，通过初始化阶段触发了驱动类的加载，类的加载依然遵循双亲委派机制

### 我们简单介绍一下SPI机制
SPI（Service Provider Interface），是JDK内置的一种服务提供发现机制。Java中SPI机制主要思想是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要，其核心思想就是解耦。
- 具体来说 当服务的提供者提供了一种接口的实现之后，需要在classpath下的META-INF/services/目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类。当其他的程序需要这个服务的时候，就可以通过查找这个jar包（一般都是以jar包做依赖）的META-INF/services/中的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行加载实例化，就可以使用该服务了。JDK中查找服务的实现的工具类是：java.util.ServiceLoader。
![](img/截屏2024-03-19%2016.01.17.png)
- 从图中可以看出，类似于设计模式中的外观模式
- 我们也可以自己使用这种方法，只要在resources目录下创建META-INF/services/，再用ServiceLoader加载即可

#### 4.4.3 OSGi模块化
- 历史上，OSGi模块化框架。它存在同级之间的类加载器的委托加载。OSGi还使用类加载器实现了热部署的功能。
  ![](img/截屏2024-03-04%2000.05.20.png)
### 4.5 jdk9之后的类加载器
- 启动类加载器使用Java编写，位于jdk.internal.loader.ClassLoaders类中。
Java中的BootClassLoader继承自BuiltinClassLoader实现从模块中找到要加载的字节码资源文件。启动类加载器依然无法通过java代码获取到，返回的仍然是null，保持了统一。
- 扩展类加载器被替换成了平台类加载器（Platform Class Loader）。
 平台类加载器遵循模块化方式加载字节码文件，所以继承关系从URLClassLoader变成了
BuiltinClassLoader，BuiltinClassLoader实现了从模块中加载字节码文件。平台类加载器的存在更多的是为了与老版本的设计方案兼容，自身没有特殊的逻辑。

## 5. 运行时数据区(JVM内存区)
- Java虚拟机在运行Java程序过程中管理的内存区域，称之为运行时数据区
![](img/截屏2024-03-04%2019.41.10.png)
### 5.1 程序计数器(PC)
- 程序计数器（Program Counter Register）也叫PC寄存器，每个线程会通过程序计数器记录当前要执行的的字节码指令的地址。
- 在加载阶段，虚拟机将字节码文件中的指令读取到内存之后，会将原文件中的偏移量转换成内存地址。每一条字节码指令都会拥有一个内存地址。在代码执行过程中，程序计数器会记录下一行字节码指令的地址。执行完当前指令之后，虚拟机的执行引擎根据程序计数器执行下一行指令。
- 程序计数器存放内存地址不存在内存溢出的情况
### 5.2 虚拟机栈
- Java虚拟机栈（Java Virtual Machine Stack）采用栈的数据结构来管理方法调用中的基本数据，先进后出（First In Last Out）,每一个方法的调用使用一个栈帧（Stack Frame）来保存。
- Java虚拟机栈随着线程的创建而创建，而回收则会在线程的销毁时进行。由于方法可能会在不同线程中执行，每个线程都会包含一个自己的虚拟机栈。
- 要修改Java虚拟机栈的大小，可以使用虚拟机参数 -Xss
### 5.3 栈帧
- 栈帧由局部变量表、操作数栈、帧数据组成
#### 5.3.1 局部变量表
- 局部变量表的作用是在方法执行过程中存放所有的局部变量。编译成字节码文件时就可以确定局部变量表的内容。
- 栈帧中的局部变量表是一个数组，数组中每一个位置称之为槽(slot) ，long和double类型占用两个槽，其他类型占用一个槽。
- 实例方法中的序号为0的位置存放的是this，指的是当前调用方法的对象，运行时会在内存中存放实例对象的地址。
- 方法参数也会保存在局部变量表中，其顺序与方法中参数定义的顺序一致。
- 局部变量表保存的内容有：实例方法的this对象，方法的参数，方法体中声明的局部变量。
- 为了节省空间，局部变量表中的槽是可以复用的，一旦某个局部变量不再生效，当前槽就可以再次被使用。
![](img/截屏2024-03-04%2019.59.05.png)

1. Nr. 是编号
2. 起始PC和长度确定了局部变量的生效范围

#### 5.3.2 操作数栈
- 操作数栈是栈帧中虚拟机在执行指令过程中用来存放中间数据的一块区域。他是一种栈式的数据结构，如果一条指令将一个值压入操作数栈，则后面的指令可以弹出并使用该值
- 在编译期就可以确定操作数栈的最大深度，从而在执行时正确的分配内存大小
![](img/截屏2024-03-04%2020.03.48.png)

#### 5.3.3 帧数据
1. 动态链接  
当前类的字节码指令引用了其他类的属性或者方法时，需要将符号引用（编号）转换成对应的运行时常量池中的内存地址。动态链接就保存了编号到运行时常量池的内存地址的映射关系。
![](img/截屏2024-03-04%2020.06.19.png)

1. 方法出口  
   方法出口指的是方法在正确或者异常结束时，当前栈帧会被弹出，同时程序计数器应该指向上一个栈帧中的下一条指令的地址。所以在当前栈帧中，需要存储此方法出口的地址
   ![](img/截屏2024-03-04%2020.06.28.png)
2. 异常表
   异常表存放的是代码中异常的处理信息，包含了异常捕获的生效范围以及异常发生后跳转到的字节码指令位置
### 5.4 本地方法栈
![](img/截屏2024-03-04%2020.10.08.png)
### 5.5 堆
- 一般Java程序中堆内存是空间最大的一块内存区域。创建出来的对象都存在于堆上
- 栈上的局部变量表中，可以存放堆上对象的引用。静态变量也可以存放堆对象的引用，通过静态变量就可以实现对象在线程之间共享。
![](img/截屏2024-03-04%2020.11.48.png)
- 堆空间有三个需要关注的值，used total max。used指的是当前已使用的堆内存，total是java虚拟机已经分配的可用堆内存，max是java虚拟机可以分配的最大堆内存。
- 在arthas中可以用 dashboard –i 刷新频率(毫秒) 查看内存
- 要修改堆的大小，可以使用虚拟机参数 –Xmx（max最大值）和-Xms (初始的total)

### 5.6 方法区
- 方法区存放三种信息 元信息 运行时常量池 字符串常量池
- 方法区是用来存储每个类的基本信息（元信息），一般称之为InstanceKlass对象。在类的加载阶段完成。(在堆中也会生成一个java.lang.Class字节码对象，供程序员使用)
  ![](img/截屏2024-03-04%2020.28.24.png)
- 注意 常量池、方法会把这两部分另外存放，这里只是引用
- XX
![](img/截屏2024-03-04%2020.32.10.png)
![](img/截屏2024-03-04%2020.32.52.png)
#### 5.6.1 运行时常量池
- 字节码文件中通过编号查表的方式找到常量，这种常量池称为静态常量池。当常量池加载到内存中之后，可以通过内存地址快速的定位到常量池中的内容，这种常量池称为运行时常量池。
![](img/截屏2024-03-04%2020.34.43.png)

### 我们深入讨论一下运行时常量池
- 运行时常量池是每一个类或者接口的常量池（Constant Pool) 的运行时的表现形式
![](img/截屏2024-03-19%2016.32.54.png)
![](img/截屏2024-03-19%2016.34.14.png)

#### 5.6.2 字符串常量池
![](img/截屏2024-03-04%2020.35.45.png)
![](img/截屏2024-03-04%2020.36.36.png)

- intern()方法  
    String.intern()方法是可以手动将字符串放入字符串常量池中
    ![](img/截屏2024-03-04%2020.45.01.png)
    ![](img/截屏2024-03-04%2020.45.17.png)
    ![](img/截屏2024-03-04%2020.45.32.png)
  - 注意 在jdk7之前字符串常量池和堆区处于不同的内存(虽然hotspot对方法区的实现为永久代，永久代也属于堆区)，在jdk7的时候串池被从方法区拿到堆区
  - 注意 对于静态变量，在jdk6之前静态变量存放在方法区永久代中 而在jdk7及之后，静态变量就脱离了永久代，转而存放在堆中的Class对象中
  - 简单来说JDK6是将我们第一次遇见的字符串复制一份放入常量池，JDK7则把第一次遇见的字符串的引用放入常量池。(一般来说现在的都是JDK7以上了)
#### 我们也来简单深入一下串池
- 字符串常量池，简单来说就是专门针对String类型设计的常量池。
- 字符串常量池的常用创建方式有两种。
  ```
    String a="Hello";
    String b=new String("Mic");
  ```
a这个变量，是在编译期间就已经确定的，会进入到字符串常量池。
b这个变量，是通过new关键字实例化，new是创建一个对象实例并初始化该实例，因此这个字符串对象是在运行时才能确定的，创建的实例在堆空间上。
![](img/截屏2024-03-19%2016.39.58.png)

关于串池中各种的相等题，不再赘述 参考： https://blog.csdn.net/qq_14876133/article/details/123714306 此篇文章都应是JDK7值后

### 我们再来介绍一下封装类常量池
- 除了字符串常量池，Java的基本类型的封装类大部分也都实现了常量池。包括Byte,Short,Integer,Long,Character,Boolean
- 封装类的常量池是在各自内部类中实现的，比如IntegerCache(Integer的内部类)。要注意的是，这些常量池是有范围的：
```
Byte,Short,Integer,Long : [-128~127]
Character : [0~127]
Boolean : [True, False]
```
封装类的常量池，其实就是在各个封装类里面自己实现的缓存实例（并不是JVM虚拟机层面的实现），如在Integer中，存在IntegerCache，提前缓存了-128~127之间的数据实例。意味着这个区间内的数据，都采用同样的数据对象。实际上就是享元设计模式。

![](img/截屏2024-03-19%2017.13.04.png)
- 上图中提到String类的不可变性，我们可以讨论一下。
```
  public final class String...
  // jdk1.8及以前String使用的是char数组，jdk1.9及以后使用的是byte数组。
  private final char value[];
```
- 关于char数组被final修饰 这应该是一个常指针 指向的内存地址不变，而不是内存地址的值不变。所有他是可以被修改的。至于不可变性，一是final修饰了整个类，二是，整个String类内没有给我们提供这样一个方法去修改char数组的值。
- 至于String类里的replace方法等，则是直接返回一个新对象
- 关于不可变性，还与多线程有关，在JUC中讨论

- 我们总结一下JDK6、7、8的变化
![](img/截屏2024-03-19%2018.01.14.png)
![](img/截屏2024-03-19%2018.01.32.png)
![](img/截屏2024-03-19%2018.01.40.png)

### 5.7 直接内存
![](img/截屏2024-03-04%2020.54.47.png)

## 6. 自动垃圾回收
- Java中为了简化对象的释放，引入了自动的垃圾回收（Garbage Collection简称GC）机制。通过垃圾回收器来对不再使用的对象完成自动的回收，垃圾回收器主要负责对堆上的内存进行回收。其他很多现代语言比如C#、Python、Go都拥有自己的垃圾回收器。

### 6.1 方法区垃圾回收
方法区中能回收的内容主要就是不再使用的类。
判定一个类可以被卸载。需要同时满足下面三个条件：
1. 此类所有实例对象都已经被回收，在堆中不存在任何该类的实例对象以及子类对象。
2. 加载该类的类加载器已经被回收。
3. 该类对应的 java.lang.Class 对象没有在任何地方被引用。

- 注意 调用System.gc()方法并不一定会立即回收垃圾，仅仅是向Java虚拟机发送一个垃圾回收的请求，具体是否需要执行垃圾回收Java虚拟机会自行判断。
- 注意 开发中此类场景一般很少出现，主要在如 OSGi、JSP 的热部署等应用场景中。
每个jsp文件对应一个唯一的类加载器，当一个jsp文件修改了，就直接卸载这个jsp类
加载器。重新创建类加载器，重新加载jsp文件。

### 6.2 堆区垃圾回收
- Java中的对象是否能被回收，是根据对象是否被引用来决定的。如果对象被引用了，说明该对象还在使用，不允许被回收。需要注意的是，当无法通过引用获取到对象时，该对象就可以被回收。
![](img/截屏2024-03-05%2011.29.39.png)

- 如上图所示，在堆内存中 A，B对象的实例互相引用，但是在栈中，已经没有办法再获得对象的引用，此时，也应该回收A,B。
#### 6.2.1 引用计数法
- 引用计数法会为每个对象维护一个引用计数器，当对象被引用时加1，取消引用时减1
- 引用计数法的优点是实现简单，C++中的智能指针就采用了引用计数法，但是它也存在缺点，主要有两点：
1. 每次引用和取消引用都需要维护计数器，对系统性能会有一定的影响
2. 存在循环引用问题，所谓循环引用就是当A引用B，B同时引用A时会出现对象无法回收的问题，可能出现内存泄漏问题。如果想要查看垃圾回收的信息，可以使用-verbose:gc参数。
#### 6.2.2 可达性分析
- Java使用的是可达性分析算法来判断对象是否可以被回收。可达性分析将对象分为两类：垃圾回收的根对象（GC Root）和普通对象，对象与对象之间存在引用关系。  
- GCRoot对象有如下几种
  - 线程Thread对象。
  - 系统类加载器加载的java.lang.Class对象。
  - 监视器对象，用来保存同步锁synchronized关键字持有的对象。
  - 本地方法调用时使用的全局对象。
  - 虚拟机栈中引用的方法
- 关于分代引用中的对象关系，这也是很重要的一点，后面讨论

#### 6.2.3 五种对象引用
1. 可达性算法中描述的对象引用，一般指的是***强引用***，即是GCRoot对象对普通对象有引用关系，只要这层关系存在，普通对象就不会被回收。
2. 软引用
   1. 软引用相对于强引用是一种比较弱的引用关系，如果一个对象只有软引用关联到它，当程序内存不足时，就会将软引用中的数据进行回收。在JDK 1.2版之后提供了SoftReference类来实现软引用，软引用常用于缓存中。
   ![](img/截屏2024-03-05%2011.41.44.png)
   2. 软引用中的对象如果在内存不足时回收，SoftReference对象本身也需要被回收。SoftReference提供了一套队列机制：
       1. 软引用创建时，通过构造器传入引用队列
       2. 在软引用中包含的对象被回收时，该软引用对象会被放入引用队列
       3. 通过代码遍历引用队列，将SoftReference的强引用删除
3. 弱引用  
弱引用的整体机制和软引用基本一致，区别在于弱引用包含的对象在垃圾回收时，不管内存够不够都会直接被回收。在JDK 1.2版之后提供了WeakReference类来实现弱引用，弱引用主要在ThreadLocal中使用。弱引用对象本身也可以使用引用队列进行回收。
4. 虚引用  
   虚引用也叫幽灵引用/幻影引用，不能通过虚引用对象获取到包含的对象。虚引用唯一的用途是当对象被垃圾回收器回收时可以接收到对应的通知。Java中使用PhantomReference实现了虚引用，直接内存中为了及时知道直接内存对象不再使用，从而回收内存，使用了虚引用来实现。
5. 终结器引用  
   终结器引用指的是在对象需要被回收时，终结器引用会关联对象并放置在Finalizer类中的引用队列中，在稍后由一条由FinalizerThread线程从队列中获取对象，然后执行对象的finalize方法，在对象第二次被回收时，该对象才真正的被回收。在这个过程中可以在finalize方法中再将自身对象使用强引用关联上，但是不建议这样做。
---
### 6.3 垃圾回收算法
![](img/截屏2024-03-05%2015.54.54.png)
  1.  Java垃圾回收过程会通过单独的GC线程来完成，但是不管使用哪一种GC算法，都会有部分阶段需要停止所有的用户线程。这个过程被称之为Stop The World简称STW，如果STW时间过长则会影响用户的使用。这个过程是每个垃圾回收器都不可避免的，就是根节点枚举阶段，这个阶段必须保证整个Java代码处于一个‘静态’。
  2.  吞吐量指的是 CPU 用于执行用户代码的时间与 CPU 总执行时间的比值，即吞吐量 = 执行用户代码时间 /（执行用户代码时间 + GC时间）。吞吐量数值越高，垃圾回收的效率就越高
  3.  最大暂停时间指的是所有在垃圾回收过程中的STW时间最大值。比如如下的图中，黄色部分的STW就是最大暂停时间，显而易见上面的图比下面的图拥有更少的最大暂停时间。最大暂停时间越短，用户使用系统时受到的影响就越短。
  4.  不同垃圾回收算法，对堆内存的使用方式是不同的。比如标记清除算法，可以使用完整的堆内存。而复制算法会将堆内存一分为二，每次只能使用一半内存。从堆使用效率上来说，标记清除算法要优于复制算法。
#### 6.3.1 标记清除算法
1. 标记阶段，将所有存活的对象进行标记。Java中使用可达性分析算法，从GC Root开始通过引用链遍历出所有存活对象。
2. 清除阶段，从内存中删除没有被标记也就是非存活对象。
![](img/截屏2024-03-05%2016.07.18.png)
- 优点：实现简单，只需要在第一阶段给每个对象维护标志位，第二阶段删除对象即可。
- 缺点：
  1. 碎片化问题
    由于内存是连续的，所以在对象被删除之后，内存中会出现很多细小的可用内存单元。如果我们需要的是一个比较大的空间，很有可能这些内存单元的大小过小无法进行分配。
  2. 分配速度慢。由于内存碎片的存在，需要维护一个空闲链表，极有可能发生每次需要遍历到链表的最后才能获得合适的内存空间。

#### 6.3.2 复制算法
1. 准备两块空间From空间和To空间，每次在对象分配阶段，只能使用其中一块空间（From空间）。
2. 在垃圾回收GC阶段，将From中存活对象复制到To空间。
3. 将两块空间的From和To名字互换。
![](img/截屏2024-03-05%2016.10.06.png)

#### 6.3.3 标记整理算法
1. 标记阶段，将所有存活的对象进行标记。Java中使用可达性分析算法，从GC Root开始通过引用链遍历出所有存活对象。
2. 整理阶段，将存活对象移动到堆的一端。清理掉存活对象的内存空间。
![](img/截屏2024-03-05%2016.11.38.png)

#### 6.3.3 分代垃圾回收算法(Generational GC)

关于分代算法，基于以下三个假设   
1. 弱分代假说:绝大多数对象朝生夕灭
2. 强分代假说:能经过越多次垃圾回收而不灭亡的对象，就越难回收，重要程度越高
3. 跨代引用假说:跨代引用相对于同代引用是极少的。

![](img/截屏2024-03-05%2016.13.43.png)
- 在JDK8中，添加-XX:+UseSerialGC参数使用分代回收的垃圾回收器，运行程序。
![](img/截屏2024-03-05%2016.14.36.png)
1. 分代回收时，创建出来的对象，首先会被放入Eden伊甸园区。
2. 随着对象在Eden区越来越多，如果Eden区满，新创建的对象已经无法放入，就会触发年轻代的GC，称为Minor GC或者Young GC。Minor GC会把需要eden中和From需要回收的对象回收，把没有回收的对象放入To区。
3. 接下来，S0会变成To区，S1变成From区。当eden区满时再往里放入对象，依然会发生Minor GC。(每次Minor GC中都会为对象记录他的年龄，初始值为0，每次GC完加1)
4. 如果Minor GC后对象的年龄达到阈值（最大15，默认值和垃圾回收器有关），对象就会被晋升至老年代。
5. 当老年代中空间不足，无法放入新的对象时，先尝试minor gc如果还是不足，就会触发Full GC，Full GC会对整个堆进行垃圾回收。如果Full GC依然无法回收掉老年代的对象，那么当对象继续放入老年代时，就会抛出Out Of Memory异常。
- 上述只是一个粗略的描述

### 6.4 垃圾回收器
1. 为什么分代GC算法要把堆分成新生代和老年代？
- 系统中的大部分对象，都是创建出来之后很快就不再使用可以被回收，比如用户获取订单数据，订单数据返回给用户之后就可以释放了。
- 老年代中会存放长期存活的对象，比如Spring的大部分bean对象，在程序启动之后就不会被回收了。
- 在虚拟机的默认设置中，新生代大小要远小于老年代的大小。

## 7.JVM原理篇

### 7.1 栈上的数据类型
1. 基本数据类型
![](img/截屏2024-03-07%2017.08.54.png)
- 在虚拟机的局部变量表中，long和double数据类型需要占据2个槽，而其他的基本数据类型占据一个槽，这是因为，long和double类型的字节数一般是8位，如果在32位的虚拟机中，需要占据2个槽，在64位中，一个槽即可，但是编译阶段无法确定机器的字长，所以为了拓展性，让这两个基本数据类型占2个槽。
- 槽的大小就是机器的字长
2. boolean类型在栈上的存储
- 实际上在字节码指令中 true对应是 1 false对应的为 0 与整形无异。
- 当我们将堆中的数据加载到栈上的时候(由小空间->大空间)：由于我们栈上空间大小大于等于堆上空间。(因为操作数栈中，我们是根据槽的大小存储数据，所以像boolean、byte、short都会占据一个槽大小为4或8个字节，而在堆上，boolean占一个字节，short占两个、byte占一个)。对于boolean、char 低位复制、高位补0。byte、short为有符号，低位复制，高位非负则补0，负则补1。
- 当我们将栈中的数据加载到堆上的时候(由大空间->小空间)：byte、char、short由于堆上存储空间较小，需要将高位去掉。boolean比较特殊，只取低位的最后一位保存。


### 7.2 对象在堆中的内存布局
![](img/截屏2024-03-07%2017.31.56.png)
- Klass pointer元数据的指针指向方法区中保存的InstanceKlass对象：
#### 7.2.1 指针压缩
- 在64位的Java虚拟机中，Klass Pointer以及对象数据中的对象引用都需要占用8个字节，为了减少这部分的内存使用量，64 位 Java 虚拟机使用指针压缩技术，将堆中原本 8个字节的 指针压缩成 4个字节 ，此功能默认开启，可以使用-XX:-UseCompressedOops关闭。所以一个普通对象头会有16个字节(64位)
- 压缩之后，为了有更大的寻址空间，我们以8字节寻址。这样做，由两个问题，一是出现大量内存碎片。我们需要进行内存的对齐，既将对象内存填充到8的整数倍(对于Hotspot来说不存在内存浪费，即便不开启指针压缩，也需要进行内存对齐)
- 其二，寻址大小仅仅能支持2的35 次方个字节（32GB，如果超过32GB指针压缩会自动关闭）。不用压缩指针，应该是2的64次方 = 16EB，用了压缩指针就变成了8（字节） = 2的3次方 * 2的32次方 = 2的35次方
#### 7.2.2 hotspot的内存对齐
- 内存对齐主要目的是为了解决并发情况下CPU缓存失效的问题：
![](img/截屏2024-03-07%2017.46.50.png)
![](img/截屏2024-03-07%2017.48.03.png)

为了实现内存对齐  
1. 字段重排列：在Hotspot中，要求每个属性的偏移量Offset（字段地址 – 起始地址）必须是字段长度的N倍（例如，有一个字段为long类型，则他的偏移量一定要是8的整数倍，如不是，那么这个字段就会被分配的不同的行）
2. 如果不满足要求，会尝试使用内存对齐，通过在属性之间插入一块对齐区域达到目的。
3. 对于继承关系，要保证父类的字段在子类之前

### 7.3 方法调用原理
### 7.3.1 静态绑定
1. 编译期间，invoke指令会携带一个参数符号引用，引用到常量池中的方法定义。方法定义中包含了类名 + 方法名 + 返回值 + 参数。
2. 在方法第一次调用时，这些符号引用就会被替换成内存地址的直接引用，这种方式称之为静态绑定。静态绑定适用于处理静态方法、私有方法、或者使用final修饰的方法，因为这些方法不能被继承之后重写。  
3. 在JVM中，一共有五个字节码指令可以执行方法调用：
   - invokestatic：调用静态方法。静态绑定
   - invokespecial: 调用对象的private方法、构造方法，以及使用 super 关键字调用父类实例的方法、构造方法，
   以及所实现接口的默认方法。静态绑定
   - invokevirtual：调用对象的非private方法。非final方法使用动态绑定，使用虚方法表找到方法的地址，子类
   会复制父类的虚方法表，如果子类重写了方法，会替换成重写后方法的地址。
   - invokeinterface：调用接口对象的方法。动态绑定，使用接口表找到方法的地址，进行调用。
   - invokedynamic：用于调用动态方法，主要应用于lambda表达式中，机制极为复杂了解即可。
4. 多态的实现
  - 在Java对象的内存结构中，对象头内的元数据指针会指向方法区的InstanceKlass。而在每个类中，会维护一张虚方法表，记录了每个方法的地址，子类会继承父类的方发表，如果子类重写父类方法，则替换为子类方法。由此实现多态。
![](img/截屏2024-03-07%2020.49.46.png)
  - invokevirtual使用了虚方法表（vtable），invokeinterface使用了接口方法表(itable)，整体思路类似

### 7.4 异常捕获
- 异常捕获机制的实现，需要借助于编译时生成的异常表。
![](img/截屏2024-03-18%2022.44.02.png)
第七行指令加载的就是异常对象
- 程序运行中触发异常时，Java 虚拟机会从上至下遍历异常表中的所有条目。当触发异常的字节码的索引值在某个异
常表条目的监控范围内，Java 虚拟机会判断所抛出的异常和该条目想要捕获的异常是否匹配。  
  - 如果匹配，跳转到“跳转PC”对应的字节码位置。
  - 如果遍历完都不能匹配，说明异常无法在当前方法执行时被捕获，此方法栈帧直接弹出，在上一层的栈帧中进行异常捕获的查询。
- finally实现的原理
  - finally中的字节码指令会插入到try 和 catch代码块中,保证在try和catch执行之后一定会执行finally中的代码。
  - 如果抛出的异常范围超过了Exception，比如Error或者Throwable，此时也要执行finally，所以异常表中增加了两个条目。覆盖了try和catch两段字节码指令的范围，any代表可以捕获所有种类的异常。
### 7.5 JIT即时编译器
- 在HotSpot中，有三款即时编译器，C1、C2和Graal，其中Graal在GraalVM章节中已经介绍过。C1编译效率比C2快，但是优化效果不如C2。所以C1适合优化一些执行时间较短的代码，C2适合优化服务端程序中长期执行的代码。
![](img/截屏2024-03-18%2022.52.11.png)
- C1即时编译器和C2即时编译器都有独立的线程去进行处理，内部会保存一个队列，队列中存放需要编译的任务。一般即时编译器是针对方法级别来进行优化的，当然也有对循环进行优化的设计。
- c1\c2的执行流程
![](img/截屏2024-03-19%2011.27.52.png)
![](img/截屏2024-03-19%2011.28.00.png)
1. 方法内联
2. 逃逸分析

## 8. 详解G1
- 关于垃圾回收的基本知识和其他的一些垃圾回收器不再赘述
1. G1
   - G1 GC有计划地避免在整个Java 堆中进行全区域的垃圾收集。G1跟踪各个Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：垃圾优先（Garbage First） 
2. 分区
   - G1采用了分区(Region)的思路，将整个堆空间分成若干个大小相等的内存区域，每次分配对象空间将逐段地使用内存。因此，在堆的使用上，G1并不要求对象的存储一定是物理上连续的，只要逻辑上连续即可；每个分区也不会确定地为某个代服务，可以按需在年轻代和老年代之间切换。启动时可以通过参数-XX:G1HeapRegionSize=n可指定分区大小(1MB~32MB，且必须是2的幂)，默认将整堆划分为2048个分区。
   ![](img/截屏2024-03-20%2017.38.47.png)
3. 分片
   - 在每个分区内部又被分成了若干个大小为512 Byte卡片(Card)，标识堆内存最小可用粒度所有分区的卡片将会记录在全局卡片表(Global Card Table)中，分配的对象会占用物理上连续的若干个卡片，当查找对分区内对象的引用时便可通过记录卡片来查找该引用对象(见RSet)。每次对内存的回收，都是对指定分区的卡片进行处理。
4. 回收方式
   - G1垃圾回收有两种方式：年轻代回收（Young GC）、混合回收（Mixed GC）
5. Young GC
    ![](img/截屏2024-03-20%2017.44.23.png)
    ![](img/截屏2024-03-20%2017.44.34.png)
    ![](img/截屏2024-03-20%2017.44.47.png)
6. Mixed GC
    ![](img/截屏2024-03-20%2017.46.33.png)
7. 关于跨代引用
   - 为了解决跨代引用问题，G1有R-set、卡表、写屏障等技术。这里我们具体讨论跨代引用本身
   - 假如出现老年代与新生代的互相引用，最直接的解决办法是，扫描整个堆。但是，在年轻代回收时，我们只回收年轻代的区域，此时扫描整个堆会大大降低效率。为此，我们利用上述的技术记录记录跨代引用的老年代对象。将这些对象加入我们的RCRoot，这样就解决了这些问题。
   - 关于G1的Young GC，在书中提到，出现跨代回收时，假如没有上述，就要从固定的RCRoot对象之外扫描整个堆区。
8. 记忆集与卡表
   - 记忆集是一种从非收集区指向收集区的指针合集。是一种抽象的数据结构
   - 卡表是记忆集的一种具体实现。
   - 具体来说，我们将区域内的内存大小分成大小相等的固定块，称为卡页。卡表的每一项与卡页一一对应如果
   - 每个区域都有自己的卡表，如果产生了跨代引用（老年代引用年轻代），此时这个Region对应的卡表上就会将字节内容进行修改,JDK8源码中0代表被引用了称为脏卡。这样就可以标记出当前Region被老年代中的哪些部分引用了。那么要生成记忆集就比较简单了，只需要遍历整个卡表，找到所有脏卡。
9. 写屏障
   - 写屏障 就是对一个对象引用进行写操作（即引用赋值）之前或之后附加执行的逻辑，相当于为引用赋值挂上的一小段钩子代码。实际就是AOP
   - 我们在写屏障中实现对卡表的改变
   - 写屏障时会先检查卡表不为脏才写，与cache-line有关
![](img/截屏2024-03-20%2019.13.10.png)
---
![](img/截屏2024-03-20%2019.15.05.png)
![](img/截屏2024-03-20%2019.15.11.png)
![](img/截屏2024-03-20%2019.15.34.png)
![](img/截屏2024-03-20%2019.15.44.png)
---

10. 混合回收
    - 多次回收之后，会出现很多Old老年代区，此时总堆占有率达到阈值（默认45%）时会触发混合回收MixedGC。混合回收会由年轻代回收之后或者大对象分配之后触发，混合回收会回收 整个年轻代 + 部分老年代 + 大对象区。老年代很多时候会有大量对象，要标记出所有存活对象耗时较长，所以整个标记过程要尽量能做到和用户线程并行执行。
    - 混合回收的步骤：  
    1、初始标记，STW，采用三色标记法标记从GC Root可直达的对象。  
    2、并发标记，并发执行，对存活对象进行标记。  
    3、最终标记，STW，处理SATB相关的对象标记。  
    4、清理，STW，如果区域中没有任何存活对象就直接清理。  
    5、转移，将存活对象复制到别的区域。  
11.  三色标记法
    ![](img/截屏2024-03-20%2019.37.54.png)
    ![](img/截屏2024-03-20%2019.38.59.png)
    ![](img/截屏2024-03-20%2019.41.23.png)
12. 其他
    - 巨型对象 Humongous Region  一个大小达到甚至超过分区大小一半的对象称为巨型对象(Humongous Object)。当线程为巨型分配空间时，不能简单在TLAB进行分配，因为巨型对象的移动成本很高，而且有可能一个分区不能容纳巨型对象。因此，巨型对象会直接在老年代分配，所占用的连续空间称为巨型分区(Humongous Region)。G1内部做了一个优化，一旦发现没有引用指向巨型对象，则可直接在年轻代收集周期中被回收。
    - ![](img/截屏2024-03-20%2019.44.57.png)
  

## JVM的拾遗
### Java语法糖
- 所谓的 语法糖 ，其实就是指 java 编译器把 *.java 源码编译为 *.class 字节码的过程中，自动生成和转换的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利
- 我们为了便于阅读，给出了 几乎等价 的 java 源码方式，并不是编译器还会转换出中间的 java 源码  
  

***默认构造器***
```
public class Candy1 {
}
```
- 编译后的代码
```
public class Candy1 {
// 这个无参构造是编译器帮助我们加上的
    public Candy1() {
      super(); // 即调用父类 Object 的无参构造方法，即调用 java/lang/Object."<init>":()V
    }
}
```
***自动拆装箱***
- 这个特性是 JDK 5 开始加入的
```
public class Candy2 {
    public static void main(String[] args) {
        Integer x = 1;
        int y = x;
    }
}
```
- 这段代码在 JDK 5 之前是无法编译通过的，必须改写为
```
public class Candy2 {
    public static void main(String[] args) {
        Integer x = Integer.valueOf(1);
        int y = x.intValue();
    }
}
```
***泛型集合取值***  
- 泛型也是在 JDK 5 开始加入的特性，但 java 在编译泛型代码后会执行 泛型擦除 的动作，即泛型信息在编译为字节码之后就丢失了，实际的类型都当做了 Object 类型来处理：
```
public class Candy3 {
    public static void main(String[] args) {
        List<Integer> list = new ArrayList<>();
        list.add(10); // 实际调用的是 List.add(Object e)
        Integer x = list.get(0); // 实际调用的是 Object obj = List.get(int index);
    }
}
```
- 所以在取值时，编译器真正生成的字节码中，还要额外做一个类型转换的操作：
```
// 需要将 Object 转为 Integer
Integer x = (Integer)list.get(0);
```
- 擦除的是字节码上的泛型信息，可以看到 LocalVariableTypeTable 仍然保留了方法参数泛型的信息
```
public static void main(String[] args) {
        List<Integer> list = new ArrayList<>();
        list.add(10);
}
```
```
 0 new #2 <java/util/ArrayList>
 3 dup
 4 invokespecial #3 <java/util/ArrayList.<init> : ()V>
 7 astore_1
 8 aload_1
 9 bipush 10
11 invokestatic #4 <java/lang/Integer.valueOf : (I)Ljava/lang/Integer;>
14 invokeinterface #5 <java/util/List.add : (Ljava/lang/Object;)Z> count 2
19 pop
20 return
```
![](img/截屏2024-04-11%2000.20.56.png)
***可变参数***  
- 可变参数 String... args 其实是一个 String[] args  
***foreach 循环***  
![](img/截屏2024-04-11%2000.22.20.png)
![](img/截屏2024-04-11%2000.22.27.png)
*** switch 字符串***  
- 从 JDK 7 开始，switch 可以作用于字符串和枚举类，这个功能其实也是语法糖，例如
```
public class Candy6_1 {
    public static void choose(String str) {
        switch (str) {
            case "hello": {
                System.out.println("h");
                break;
            }
            case "world": {
                System.out.println("w");
                break;
            }
        }
    }
}
```
```
public class Candy6_1 {
    public Candy6_1() {
    }
    public static void choose(String str) {
        byte x = -1;
        switch(str.hashCode()) {
            case 99162322: // hello 的 hashCode
                if (str.equals("hello")) {
                x = 0;
            }
            break;
            case 113318802: // world 的 hashCode
                if (str.equals("world")) {
                x = 1;
            }
        }
        switch(x) {
            case 0:
                System.out.println("h");
                break;
            case 1:
                System.out.println("w");
        }
    }
}
```
- 可以看到，执行了两遍 switch，第一遍是根据字符串的 hashCode 和 equals 将字符串的转换为相应byte 类型，第二遍才是利用 byte 执行进行比较。
- 原因是 直接根据hashCode比较可以提高效率(只用equals会变成单纯的if-else的嵌套)，但是 hashCode有可能出现冲突 两个字符串 equals为true hashCode一定为正，反过来则不一定。    

***枚举类***    
- JDK 7 新增了枚举类，以前面的性别枚举为例
```
enum Sex {
    MALE, FEMALE
}
```
![](img/截屏2024-04-11%2000.30.22.png)
- 上面是枚举类在JVM内的样子，可以看出 枚举类还是一个Java类，类的初始化放在了static代码块中，我们可以知道，这会在类的初始化阶段会执行静态代码块中的代码(只会执行一次)。而这个类对java程序员都不可见，可以解释枚举类关于单例模式的最好选择
*** try-with-resources***  
- JDK 7 开始新增了对需要关闭的资源处理的特殊语法 try-with-resources`：
```
try(资源变量 = 创建资源对象){

} catch( ) {

}
```
-其中资源对象需要实现 AutoCloseable 接口，例如 InputStream 、 OutputStream 、Connection 、 Statement 、 ResultSet 等接口都实现了 AutoCloseable ，使用 try-withresources 可以不用写 finally 语句块，编译器会帮助生成关闭资源代码，例如：

- 我们不太关心这个的具体实现，但是，我们借着这个机会，想谈谈Java的异常机制的一些部分(代码层面，字节码层面的已经讨论过)
- 参考 ： https://blog.csdn.net/ligonglanyuan/article/details/122714586 我们把其中有趣的地方拿出来


***匿名内部类***  
- 关于这个，我们只需要知道，匿名内部类会被编译成一个新的类。
- 我们还要讨论一点，为什么匿名内部类引用局部变量时，局部变量必须是 final 的。因为在创建匿名内部类 对象时，将 局部变量 的值赋值给了 匿名内部类$1 对象的  属性，所以  属性不应该再发生变化了，如果变化，那么 val$x 属性没有机会再跟着一起变化
- 当然，在Java8之后，不用加final 了，这也是新的语法糖  

***方法重写时的桥接方法***  
- 我们都知道，方法重写时对返回值分两种情况：
  - 父子类的返回值完全一致
  - 子类返回值可以是父类返回值的子类（比较绕口，见下面的例子）
![](img/截屏2024-04-11%2000.43.00.png)
![](img/截屏2024-04-11%2000.43.12.png)
